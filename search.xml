<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwntools語法</title>
      <link href="/2025/08/04/pwntools%E8%AA%9E%E6%B3%95/"/>
      <url>/2025/08/04/pwntools%E8%AA%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Pwntools"><a href="#Pwntools" class="headerlink" title="Pwntools"></a>Pwntools</h1><p>記得先 <code>pip3 install pwntools</code></p><span id="more"></span><h2 id="各種語法"><a href="#各種語法" class="headerlink" title="各種語法"></a>各種語法</h2><p><code>gedit 檔名.py</code> 創建檔案<br><code>from pwn import *</code> 引入pwn<br><code>r = remote(&#39;主機位址&#39;, port)</code> 進行nc連線<br><code>r.recvn(N)</code> 接受 N 個字元<br><code>r.recvline()</code> 接收一行資料<br><code>r.recvlines(N)</code> 接收 N 行資料<br><code>r.recvuntil(some_string)</code> 接收到 some_string 為止🌰<code>r.recvuntil(b&#39;answer: &#39;) </code> (要加b因為recvuntil回傳的是bytes形式)<br><code>r.send(payload)</code> 發送payload(需為字串)<br><code>r.sendline(payload)</code> 發送payload，並換行（末尾\n）<br><code>r.sendafter(some_string, payload)</code> 接收到 some_string 後, 發送 payload<br><code>r.sendlineafter(some_string, payload)</code> 接收到 some_string 後, 發送 payload並換行<br><code>r.interactive()</code> 輸入 logout 離開連接端 shell，與 shell 互動<br><code>r.close()</code> 將remote連線結束</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wireshark筆記</title>
      <link href="/2025/08/04/wireshark%E7%AD%86%E8%A8%98/"/>
      <url>/2025/08/04/wireshark%E7%AD%86%E8%A8%98/</url>
      
        <content type="html"><![CDATA[<h1 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h1><span id="more"></span><h2 id="一點先備知識🍘🧀"><a href="#一點先備知識🍘🧀" class="headerlink" title="一點先備知識🍘🧀"></a>一點先備知識🍘🧀</h2><ul><li>公用 IP 位址<ul><li>公用 IP 位址向其 Internet 服務提供者 (ISP) 和 Internet 的其餘部分識別電腦。 公用 IP 位址可以唯一地識別一台電腦或充當專用網路的共用存取點</li></ul></li><li>私有 IP 位址<ul><li>識別本地網路內的電腦</li><li>範圍<ul><li>192.168.0.0–192.168.255.255（65,536 個 IP 位址）</li><li>172.16.0.0–172.31.255.255（1,048,576 個 IP 位址）</li><li>10.0.0.0–10.255.255.255（16,777,216 個 IP 位址）</li></ul></li></ul></li><li>Ports<ul><li>Ports 0 to 1023 are Well-Known Ports.<ul><li>通常被指派給特定的網路服務</li><li>21：FTP（File Transfer Protocol）</li><li>22：SSH（Secure Shell）</li><li>80：HTTP（HyperText Transfer Protocol）</li><li>443：HTTPS（HyperText Transfer Protocol Secure）</li></ul></li><li>Ports 1024 to 49151 are Registered Ports.<ul><li>通常用於特定的應用程式或專有軟體</li><li>3306：MySQL 資料庫</li><li>5432：PostgreSQL 資料庫</li><li>27017：MongoDB</li></ul></li><li>Ports 49152 to 65535 are Public Ports.<ul><li>通常用於臨時連線（Ephemeral Ports）</li><li>例如當用戶端連接到伺服器時，系統會自動分配一個動態端口來處理回應</li></ul></li></ul></li></ul><h2 id="常用選項"><a href="#常用選項" class="headerlink" title="常用選項"></a>常用選項</h2><h3 id="統計（Statistics）功能"><a href="#統計（Statistics）功能" class="headerlink" title="統計（Statistics）功能"></a>統計（Statistics）功能</h3><ul><li>協議分級<ul><li>Statistics → Protocol Hierarchy</li><li>會顯示封包中 不同協議的比例</li><li>分析封包裡的 協議組成比例，看看主要的通訊是什麼</li><li>CTF 中可以用來判斷<strong>是否有不尋常的協議？</strong>（例如比賽題目裡偷偷用了某個不常見的協議來藏 flag）</li></ul></li><li>查詢常見IP<ul><li>Statistics -&gt; Conversations -&gt; IPv4 -&gt; Bytes(點擊兩次可使從大到小排序)</li><li>可以列出 <strong>封包最多或流量最高的IP</strong>，幫助找出 <strong>主要通訊的IP</strong> 位址</li><li>在CTF中，通常用來 <strong>找出有價值的 IP</strong> 來進一步分析</li></ul></li></ul><h3 id="檢視下載的資源"><a href="#檢視下載的資源" class="headerlink" title="檢視下載的資源"></a>檢視下載的資源</h3><ul><li>File -&gt; Export Objects -&gt; HTTP (Figure)</li><li>Wireshark 會列出所有 透過 HTTP 下載的檔案（例如 .exe, .png, .zip 等）</li><li>選擇檔案 → 點擊「Save」存下來</li><li>除了 HTTP，也可以試試：<ul><li>Export Objects → SMB（Windows 共享檔案）</li><li>Export Objects → FTP（FTP 傳輸的檔案）</li></ul></li><li>CTF 常見考點：下載被隱藏的檔案，看看裡面藏了什麼（可能是 flag）</li></ul><h2 id="過濾指令"><a href="#過濾指令" class="headerlink" title="過濾指令"></a>過濾指令</h2><h3 id="過濾協議"><a href="#過濾協議" class="headerlink" title="過濾協議"></a>過濾協議</h3><ul><li>直接輸入協議名即可過濾出對應數據。例如：<ul><li>tcp：顯示所有 TCP 數據</li><li>udp：顯示所有 UDP 數據</li><li>arp、icmp、http、smtp、ftp、dns、ssl、ssh 等同理</li></ul></li></ul><h3 id="過濾IP"><a href="#過濾IP" class="headerlink" title="過濾IP"></a>過濾IP</h3><ul><li>常用字段:<ul><li>ip.src：源 IP 地址</li><li>ip.dst：目標 IP 地址</li><li>ip.addr：匹配數據中出現的任一IP 地址（即包括源及目標）</li><li>🌰過濾某個IP的數據:<code>ip.src == 192.168.1.100 or ip.dst == 192.168.1.100</code> or <code>ip.addr == 192.168.1.100</code></li></ul></li><li>不等於<ul><li>Wireshark不支持直接用 <code>!=</code> 表達不等，需要用 <code>not ...==... </code>或 <code>!</code> 來表達</li><li>🌰過濾出TCP端口不為3389 &amp; IP位址不為10.135.71.54 &amp; 端口不為80 : <code>not tcp.port == 3389 and not ip.addr == 10.135.71.54 and not tcp.port == 80 </code></li></ul></li></ul><h3 id="過濾端口"><a href="#過濾端口" class="headerlink" title="過濾端口"></a>過濾端口</h3><ul><li>常用字段:<ul><li>tcp.port：匹配 TCP 數據中（包括源及目標）的端口號</li><li>tcp.srcport 與 tcp.dstport：分别表示 TCP 源端口和目標端口</li><li>udp.port：匹配 UDP 數據的端口號</li></ul></li><li>🌰過濾TCP端口443:<code>tcp.port eq 443</code></li></ul><h3 id="過濾方向"><a href="#過濾方向" class="headerlink" title="過濾方向"></a>過濾方向</h3><ul><li>有時候需要區分流量的方向</li><li>常用關鍵字<ul><li>對IP : <code>src</code>、<code>dst</code>、<code>src and dst</code>、<code>src or dst</code></li><li>對端口 : <code>srcport</code>、<code>dstport</code>、<code>srcport and dstport</code>、<code>srcport or dstport</code></li></ul></li><li>🌰源IP為10.0.0.1 : <code>ip.src == 10.0.0.1</code></li></ul><h3 id="過濾HTTP"><a href="#過濾HTTP" class="headerlink" title="過濾HTTP"></a>過濾HTTP</h3><ul><li>過濾http模式<ul><li><code>http.request.method == &quot;HEAD&quot;</code></li><li><code>http.request.method == &quot;GET&quot;</code></li><li><code>http.request.method == &quot;POST&quot;</code></li></ul></li><li>模糊匹配字符串<ul><li>有時候flag或關鍵信息可能隱藏在URL、Server字段或整個HTTP數據中</li><li>🌰在URL中包含特定字符串:<code>http.request.uri contains &quot;string&quot;</code></li><li>🌰整個HTTP數據中包含某字符串:<code>http contains &quot;string&quot;</code></li></ul></li></ul><h3 id="tcp-stream過濾"><a href="#tcp-stream過濾" class="headerlink" title="tcp stream過濾"></a>tcp stream過濾</h3><ul><li>篩選屬於同一TCP流的數據，便於對話重組和整體分析</li><li>🌰查看TCP流5的數據 : <code>tcp.stream eq 5</code></li></ul><h3 id="過濾字串"><a href="#過濾字串" class="headerlink" title="過濾字串"></a>過濾字串</h3><ul><li>用 <code>contains</code> 來過濾字串 : <ul><li><strong>模糊搜尋</strong>，只要有包含該字串就會被篩選出來</li><li><code>http contains &quot;flag&quot;</code>：搜尋 HTTP 協議的封包內容中有出現 <code>&quot;flag&quot;</code> 字樣的</li><li><code>tcp contains &quot;login&quot;</code>：搜尋 TCP 的 Payload 裡有 <code>&quot;login&quot;</code> 的封包</li><li><code>dns.qry.name contains &quot;example.com&quot;</code>：DNS 查詢中包含特定域名</li></ul></li><li>萬用搜尋 : <ul><li><code>frame contains &quot;string&quot;</code>：搜尋整個封包（不管哪一層）中出現 <code>&quot;string&quot;</code>的封包</li></ul></li></ul><h2 id="CTF常見題型"><a href="#CTF常見題型" class="headerlink" title="CTF常見題型"></a>CTF常見題型</h2><h3 id="PCAP分析"><a href="#PCAP分析" class="headerlink" title="PCAP分析"></a>PCAP分析</h3><ul><li>給一個PCAP檔案，需要利用wireshark篩選出關鍵信息，如隱藏的字符串、密碼、用戶名或flag</li><li>常見技巧<ul><li>使用<strong>filter</strong>排除無關流量</li><li>利用 <strong>follow TCP stream</strong> 重組會話數據</li><li>結合 <strong>Export Objects</strong>功能提取HTTP、FTP等協議中傳輸的文件</li></ul></li></ul><h3 id="HTTP-流量分析"><a href="#HTTP-流量分析" class="headerlink" title="HTTP 流量分析"></a>HTTP 流量分析</h3><ul><li>分析HTTP請求和響應數據，從中提取隱藏信息</li><li>常見技巧:<ul><li>過濾出 GET&#x2F;POST 請求</li><li>搜尋請求中包含的數據、Cookie、User-Agent等</li><li>檢查響應包中的HTML或JSON數據</li></ul></li></ul><h3 id="USB流量分析"><a href="#USB流量分析" class="headerlink" title="USB流量分析"></a>USB流量分析</h3><ul><li>提供USB流量抓包，考察選手對USB協議中鍵盤輸入或鼠標移動數據的解析能力</li><li>常見技巧<ul><li>根據數據包長度和格式區分鍵盤和鼠標流量</li><li>利用過濾命令，如過濾數據包中某字節範圍(如USB數據中第三個字節代表鑑碼)</li><li>編寫腳本將提取出的鑑碼映射為實際按鍵，從而重構出輸入的內容</li></ul></li></ul><h3 id="工控協議流量分析"><a href="#工控協議流量分析" class="headerlink" title="工控協議流量分析"></a>工控協議流量分析</h3><ul><li>工控協議(如Modbus、IEC 104、MMS)等，需分析協議數據並從中提取FLAG</li><li>常見技巧<ul><li>利用過濾器定位特定功能碼或命令</li><li>根據協議結構找到數據段，進行數據提取和轉碼</li><li>結合wireshark的統計功能(如協議分級、TCP流號) 定位異常或關鍵流量</li></ul></li></ul><h3 id="隱寫或異常流量"><a href="#隱寫或異常流量" class="headerlink" title="隱寫或異常流量"></a>隱寫或異常流量</h3><ul><li>流量中可能隱藏有編碼、加密或經過隱寫處理的數據，需結合其他工具進行解碼和還原</li><li>常見技巧<ul><li>利用過濾器查找包含特殊標誌的字符串或字節序列</li><li>導出 payload數據後嘗試不同的解碼方式</li><li>分析數據包中的異常字段，如錯誤的校驗和、非標準端口 等</li></ul></li></ul><h2 id="題目練習"><a href="#題目練習" class="headerlink" title="題目練習"></a>題目練習</h2><h3 id="CTF-Academy"><a href="#CTF-Academy" class="headerlink" title="CTF Academy"></a><a href="https://ctfacademy.github.io/network/index.htm#NetworkForensics">CTF Academy</a></h3><h3 id="Wireshark-doo-dooo-do-doo…"><a href="#Wireshark-doo-dooo-do-doo…" class="headerlink" title="Wireshark doo dooo do doo…"></a><a href="https://play.picoctf.org/practice/challenge/115?category=4&page=4">Wireshark doo dooo do doo…</a></h3><p>題目給了一個pcapng檔，用wireshark打開他<br>打開會看到一堆TCP其中夾雜一點HTTP<br>在其中一個TCP封包上選擇follow -&gt; TCP stream<br>然後不斷調整stream的數字，最後在第五個找到很像flag的東西<br>看起來就是凱撒密碼，拿去做解密就是flag!</p><h3 id="Wireshark-twoo-twooo-two-twoo…"><a href="#Wireshark-twoo-twooo-two-twoo…" class="headerlink" title="Wireshark twoo twooo two twoo…"></a><a href="https://play.picoctf.org/practice/challenge/110?category=4&page=4">Wireshark twoo twooo two twoo…</a></h3><p>這題一樣是給了一個pcapng檔<br>打開來之後我先照著上一題那樣選follow -&gt; TCP stream<br>翻了一下找到一個picoCTF的字串，繼續往後翻，又翻到一堆picoCTF開頭字串<br>觀察這幾個有甚麼共通點，發現他的Host都是18.217.1.57<br>用過濾器過濾出每個Host:18.217.1.57，用<code>ip.src ==18.217.1.57</code><br>發現一堆HTTP跟DNS中夾雜著一些DNS，觀察一下發現看起來像base64的東西<br>再把dns也過濾出來<code> ip.src ==18.217.1.57 &amp;&amp; dns</code><br>把每個.reddshrimpandherring.com.windomain.local前的字串提取出來拿去做base64解碼，就是flag了 !</p><h3 id="shark-on-wire-1"><a href="#shark-on-wire-1" class="headerlink" title="shark on wire 1"></a><a href="https://play.picoctf.org/practice/challenge/30?category=4&page=5">shark on wire 1</a></h3><p>打開後觀察一下，他跟之前寫的有點不一樣，他比較多的是ARP跟UDP<br>一樣follow TCP stream試試看，發現啥都沒有<br>換選擇follow UDP stream，不斷往後按就找到flag了</p><h3 id="shark-on-wire-2"><a href="#shark-on-wire-2" class="headerlink" title="shark on wire 2"></a><a href="https://play.picoctf.org/practice/challenge/84?category=4&page=4">shark on wire 2</a></h3><h3 id="PcapPoisoning"><a href="#PcapPoisoning" class="headerlink" title="PcapPoisoning"></a><a href="https://play.picoctf.org/practice/challenge/362?category=4&page=2&search=">PcapPoisoning</a></h3><p>這題給了一個封包，裡面充滿各種東西<br>好幾個裡面都寫一樣的東西<br>一個一個找太久了用filter來搜尋<br><code>frame contains &quot;pico&quot;</code><br>找所有封包內容中有出現 “pico” 的位置<br><img src="https://hackmd.io/_uploads/BkHq67SJex.png" alt="image"><br>找到flag了!</p><h3 id="Packets-Primer"><a href="#Packets-Primer" class="headerlink" title="Packets Primer"></a><a href="https://play.picoctf.org/practice/challenge/286?category=4&page=1&search=Packets%20Primer">Packets Primer</a></h3><p>這題給了一個pcap檔案<br>打開來只有少少幾個封包<br>翻了一下就在其中一個封包裡面看到flag了<br><img src="https://hackmd.io/_uploads/SkZXLNBygg.png" alt="image"></p><h3 id="Eavesdrop"><a href="#Eavesdrop" class="headerlink" title="Eavesdrop"></a><a href="https://play.picoctf.org/practice/challenge/264?category=4&page=1&search=Eavesdrop">Eavesdrop</a></h3><p>這題給了一個pcap，打開之後是一些tcp封包<br>先用follow tcp stream<br>在 stream 0 可以看到一段對話，告訴我們解密方法跟去哪找密文<del>但其實我發現繼續翻tcp stream就可以看到了根本不用搜port</del><br>找到之後要<strong>先將他翻成hex格式</strong>，不能用ascii格式<br>然後要存成binary格式<br><code>echo &quot;53616c7465645f5f3c4b26e8b8f91e2c4af8031cfaf5f8f16fd40c25d40314e6497b39375808aba186f48da42eefa895&quot; | xxd -r -p &gt; file.des3</code><br>然後用題目給的解密方法<br><code>openssl des3 -d -salt -in file.des3 -out file.txt -k supersecretpassword123</code><br>打開解密出來的檔案就是flag了<br><img src="https://hackmd.io/_uploads/H1WaoVBkxx.png" alt="image"></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.checkpoint.com/tw/cyber-hub/network-security/what-is-an-ip-address/">What is an IP Address</a><br><a href="https://cloud.tencent.com/developer/article/1618433">wireshark常用过滤命令</a><br><a href="https://medium.com/@yansi.keim/wireshark-basics-http-traffic-analysis-for-playing-ctf-competitions-f165778e99e2">Wireshark Basics (HTTP Traffic Analysis) for playing CTF Competitions</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Disk筆記</title>
      <link href="/2025/08/04/Disk%E7%AD%86%E8%A8%98/"/>
      <url>/2025/08/04/Disk%E7%AD%86%E8%A8%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h1><h2 id="Sleuth-Kit（TSK）指令整理"><a href="#Sleuth-Kit（TSK）指令整理" class="headerlink" title="Sleuth Kit（TSK）指令整理"></a>Sleuth Kit（TSK）指令整理</h2><span id="more"></span><h3 id="img-stat"><a href="#img-stat" class="headerlink" title="img_stat"></a>img_stat</h3><ul><li>用途：查看磁碟映像檔的基本資訊（大小、磁區大小、類型、分割資訊）</li><li>使用時機：拿到 .img 或 .dd 檔的第一步，先了解這顆磁碟的結構</li><li>🌰 <code>img_stat disk.img</code></li></ul><h3 id="mmls"><a href="#mmls" class="headerlink" title="mmls"></a>mmls</h3><ul><li>用途：顯示磁碟映像檔內的分割區資訊（MBR&#x2F;GPT 分割區表）</li><li>使用時機：確認檔案系統從哪個 offset 開始，供後續指令使用</li><li>🌰<code>mmls disk.img</code></li><li>📌 注意 Start 欄位的數值，後續像 fls、icat 要用 <code>-o &lt;offset&gt;</code></li></ul><h3 id="fsstat"><a href="#fsstat" class="headerlink" title="fsstat"></a>fsstat</h3><ul><li>用途：顯示某個檔案系統的細節（例如 FAT&#x2F;EXT&#x2F;NTFS 的 metadata 結構）</li><li>使用時機：分析文件系統類型與結構</li><li>🌰<code>fsstat -o 2048 disk.img</code></li></ul><h3 id="fls"><a href="#fls" class="headerlink" title="fls"></a>fls</h3><ul><li>用途：列出檔案系統中的檔案與目錄（包含已刪除的）</li><li>使用時機：找到目標檔案或目錄（例如 flag.txt 或特定資料夾）</li><li>🌰<code>fls -o 2048 -r disk.img</code></li><li>🌰<code>fls -o 2048 -r disk.img 16</code></li></ul><h3 id="ffind"><a href="#ffind" class="headerlink" title="ffind"></a>ffind</h3><ul><li>用途：透過檔案名稱找出 inode 號碼</li><li>使用時機：若你知道檔名（例如 “flag.txt”）但不想手動看 fls 結果，可快速找 inode</li><li>🌰 <code>ffind -o 2048 disk.img flag.txt</code></li></ul><h3 id="tsk-recover"><a href="#tsk-recover" class="headerlink" title="tsk_recover"></a>tsk_recover</h3><ul><li>用途：從映像檔中恢復檔案（包含刪除檔）</li><li>使用時機：想直接將檔案系統內容 dump 出來分析（不用一個個 icat）</li><li>🌰<code>tsk_recover -o 2048 disk.img output_dir/</code></li><li><blockquote><p>會把整個分割區的檔案複製到 output_dir，可以直接用 ls 看</p></blockquote></li></ul><h3 id="icat"><a href="#icat" class="headerlink" title="icat"></a>icat</h3><ul><li>用途：依 inode 號碼從映像檔中提取單一檔案</li><li>使用時機：用 fls 找到特定檔案 inode 後，用來匯出內容</li><li>作用檔案：磁碟映像檔</li><li>🌰<code>icat -o 2048 disk.img 128</code></li><li>📌 上面會把 inode 為 128 的檔案內容印出來，可以用 &gt; output 存檔</li></ul><h3 id="istat"><a href="#istat" class="headerlink" title="istat"></a>istat</h3><ul><li>用途：顯示指定 inode 的 metadata（建立時間、大小、狀態）</li><li>使用時機：想知道檔案什麼時候被建立、是否刪除、還在不在</li><li>🌰 <code>istat -o 2048 disk.img 128</code></li><li>📌 刪除檔案也會有 metadata（可能幫助你確認「flag.txt 是不是被刪掉」）</li></ul><h3 id="blkls"><a href="#blkls" class="headerlink" title="blkls"></a>blkls</h3><ul><li>用途：直接印出資料區塊（raw data）</li><li>使用時機：想用 strings 擷取出某些資料，像是被藏起來的 flag、png 頭之類的 raw data</li><li>🌰 <code>blkls -o 2048 disk.img &gt; raw.bin &amp;&amp; strings raw.bin | grep CTF</code></li></ul><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><h3 id="picoCTF-Sleuthkit-Intro"><a href="#picoCTF-Sleuthkit-Intro" class="headerlink" title="picoCTF-Sleuthkit Intro"></a><a href="https://play.picoctf.org/practice/challenge/301?category=4&page=3&search=">picoCTF-Sleuthkit Intro</a></h3><p>題目給了一個img檔案跟一個nc連線的資訊<br>先連線上去看他要問什麼，他要問的是Linux部分的長度<br><img src="https://hackmd.io/_uploads/SylCp1_0Jx.png" alt="image"><br>題目已經有告訴我們要用mmls了，所以就<code>mmls disk.img</code><br><img src="https://hackmd.io/_uploads/rkx1CydA1e.png" alt="image"><br>第三行的length就是答案了，送出答案就會得到flag了</p><h3 id="picoCTF-Sleuthkit-Apprentice"><a href="#picoCTF-Sleuthkit-Apprentice" class="headerlink" title="picoCTF-Sleuthkit Apprentice"></a><a href="https://play.picoctf.org/practice/challenge/300?category=4&page=3&search=">picoCTF-Sleuthkit Apprentice</a></h3><p>題目給了一個disk檔<br>下載之後用<code>gunzip</code>解壓縮<br>然後用<code>mmls</code>查看分隔區表<br><img src="https://hackmd.io/_uploads/SyQvP5D01l.png" alt="image"><br>有兩個Linux分隔區<br>分別用<code>fsstat -o 2048 disk.flag.img </code>跟<code>fsstat -o 360448 disk.flag.img</code>查看內容<br>發現第二個<code>Last mounted on: /</code>所以應該是要找這個<br><img src="https://hackmd.io/_uploads/HkcRDcwA1x.png" alt="image"><br>用<code>fls -o 360448 disk.flag.img</code>查看目錄<br>然後<code>fls -o 360448 disk.flag.img 1995</code>發現root下有資料夾<br><code>fls -o 360448 disk.flag.img 3981</code>找到兩個檔案(一個被刪除了)<br>用<code>tsk_recover -e -o 360448 disk.flag.img -d 3981 Apprentice/</code>導出資料夾裡的所有檔案，cat 檔案就能找到flag</p><h3 id="picoCTF-Disk-disk-sleuth"><a href="#picoCTF-Disk-disk-sleuth" class="headerlink" title="picoCTF-Disk, disk, sleuth!"></a><a href="https://play.picoctf.org/practice/challenge/113?category=4&page=4&search=">picoCTF-Disk, disk, sleuth!</a></h3><p>這題說要用srch_strings，上網查發現它可以印出可視字串<br>直接使用會噴出一堆東西，所以要搭配grep進行搜尋<br><code>srch_strings dds1-alpine.flag.img | grep &quot;CTF&quot;</code>然後就找到flag了</p><h3 id="picoCTF-Disk-disk-sleuth-II"><a href="#picoCTF-Disk-disk-sleuth-II" class="headerlink" title="picoCTF-Disk, disk, sleuth! II"></a><a href="https://play.picoctf.org/practice/challenge/137?category=4&page=4&search=">picoCTF-Disk, disk, sleuth! II</a></h3><p>這題一樣解壓縮後用 <code>mmls dds2-alpine.flag.img</code>確認分隔區<br>我們現在知道要找的檔案的名字，所以可以直接讓他列出全部的檔案再搜尋<br><code>fls -o 2048 -r dds2-alpine.flag.img| grep &quot;down-at-the-bottom&quot;</code><br><img src="https://hackmd.io/_uploads/SyWy65DC1g.png" alt="image"><br>找到之後用<code>icat -o 2048 dds2-alpine.flag.img 18291 &gt; dds2.txt</code>提取檔案<br><code>cat dds2.txt</code>會出現<img src="https://hackmd.io/_uploads/H1XLQp9vCye.png" alt="image"><br>組合起來就是flag</p><h3 id="picoCTF-Operation-Oni"><a href="#picoCTF-Operation-Oni" class="headerlink" title="picoCTF-Operation Oni"></a><a href="https://play.picoctf.org/practice/challenge/284?category=4&page=3&search=">picoCTF-Operation Oni</a></h3><p>下載之後解壓縮，用mmls查看分隔區<br>分別用<code>fsstat -o 2048 disk.img </code>跟<code>fsstat -o 206848 disk.img</code>查看內容<br>發現第二個<code>Last mounted on: /</code>所以應該是要找這個<br><code>fls -o 206848 disk.img</code>然後通常私鑰預設就會存在<code>root</code>底下<br>進去root看看<code>fls -o 206848 disk.img 470</code><br><img src="https://hackmd.io/_uploads/BJBC91OCJl.png" alt="image"><br>看到一個叫.ssh的目錄，再進去可以看到兩個檔案<br><img src="https://hackmd.io/_uploads/SkG7j1uCJg.png" alt="image"><br>分別查看兩個檔案內容<br><img src="https://hackmd.io/_uploads/rJHCql5bxx.png" alt="螢幕擷取畫面 2025-05-20 204954"><br>導出id_ed25519這個檔案<code>icat -o 206848 disk.img 2345 &gt; ssh1.txt</code><br>然後加權限給他<code>chmod 600 ssh1.txt</code><br>用這個檔案進行ssh連線後<code>cat flag.txt</code>就找到flag了<br><img src="https://hackmd.io/_uploads/Bkc9jyuRJg.png" alt="image"></p><h3 id="picoCTF-Operation-Orchid"><a href="#picoCTF-Operation-Orchid" class="headerlink" title="picoCTF-Operation Orchid"></a><a href="https://play.picoctf.org/practice/challenge/285?category=4&page=3&search=">picoCTF-Operation Orchid</a></h3><p>解壓縮後用<code>mmls</code>查看分隔區表<br><img src="https://hackmd.io/_uploads/B1BWM-cZlx.png" alt="image"><br>一跟三是linux分隔區，分別用<code>fsstat</code>查看內容<br><img src="https://hackmd.io/_uploads/Bkhk3b9-ge.png" alt="image"><img src="https://hackmd.io/_uploads/S1O-n-cbex.png" alt="image"><br>第三個<code>Last mounted on: /</code>所以猜是在第三個這個裡面<br>用<code>fls -o 411648 disk.flag.img</code>查看一下目錄<img src="https://hackmd.io/_uploads/S1HOnW5bex.png" alt="image"><br>查看root目錄，發現加密過的flag檔案<br><img src="https://hackmd.io/_uploads/ryxA2Wcblg.png" alt="image"><br>用 <code>strings -t d disk.flag.img | grep flag.txt</code>尋找金鑰在哪<br><img src="https://hackmd.io/_uploads/H1xVaW9bel.png" alt="image"><br>找到<code>openssl aes256 -salt -in flag.txt -out flag.txt.enc -k unbreakablepassword1234567</code><br>用<code>icat -o 411648 disk.flag.img 1782 &gt; flag.txt.enc</code>導出檔案，再用密鑰進行解密，然後就可以得到flag<br><img src="https://hackmd.io/_uploads/rkei6ZcWxe.png" alt="image"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

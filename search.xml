<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AIS3流水帳心得文</title>
      <link href="/2025/08/06/AIS3%E6%B5%81%E6%B0%B4%E5%B8%B3%E5%BF%83%E5%BE%97%E6%96%87/"/>
      <url>/2025/08/06/AIS3%E6%B5%81%E6%B0%B4%E5%B8%B3%E5%BF%83%E5%BE%97%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>2025的一點流水帳</p><span id="more"></span><h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>這天其實就是去睡覺的（？）行李好重交大的路好難走我甚至忘記房間號是多少然後又走回去一次www<br>聽大家在聊天有種有神快拜的感覺，無助高中生不知道說什麼._.</p><p>晚餐:7-11</p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>早上是軟體主修，其實大部分都聽不懂但中午聊天發現大家也都聽不懂突然安心了（？）<br>中午是校友分享，印象最深的就是只投一間台科要嘛讀大學要嘛投正職，太電了🛐🛐<br>下午是AI主修跟CTF主修，因為我是AI組的所以AI聽的挺認真的，CTF組的沒意外聽不懂，享受了知識從大腦流過並且沒有留下任何痕跡的感覺<br>晚上的破冰，呃，好難._. 我解了最簡單的第三題，組員解了第一題。回宿舍跟他們線上討論了一下專題就跑去睡覺了</p><p>早餐:無<br>午餐:主辦請的subway<br>晚餐:丼飯 (不喜歡海帶芽)</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>早上連續兩節偏理論的課，一邊看著簡報一邊看著共筆在思考什麼是重點ww<br>下午第一堂是我期待很久的課!講跟語言模型有關的攻擊技巧，之前解過相關題目但也只知道prompt injection，長超多知識但lab還是只會跟著老師做QQ<br>下午第二堂分別是量子電腦跟Linux，因為覺得聽Linux的話知識又會從大腦流過所以跑去聽量子電腦，然後學了一堆密碼學跟數學，感覺每次聽量子電腦最後都會變成學一堆密碼學<br>晚上是產業鏈結交流會，好多公司福利好好，印象最深的是周休三天所以你只要請四天就能連休10天www挺合理的，炸雞跟pizza被放到有點冷掉了TT，但免費晚餐還是讚</p><p>早餐:無<br>午餐:滷肉飯 (有點太多了吃不完qq)<br>晚餐:炸雞 &amp; pizza</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>早上的AI課其實看到課程名稱就猜到我應該聽不太懂，80%逆向+20%AI :(<br>早上第二堂我上軟體，恩，第一堂沒聽我開頭就矇了<br>下午上AI選修，比早上友善多了，記了很多筆記:D 但感覺都比較理論知識<br>晚上是講座，聽了幾乎可以算是台灣CTF很早期的時期的故事，超有趣的，slido的白色恐怖真的超好笑</p><p>早餐:7-11熱狗<br>午餐:茗松燒肉飯<br>晚餐:subway軟餅乾<br>消夜:7-11的爆汁嫩雞</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>早上第一堂是接續昨天下午的AI課，對然後我也不知道為什麼全部在上逆向，後面在講自動化紅隊 <del>很老實的說我第一次聽MCP介紹</del><br>下午是萬種矚目的orange的課!! 開局先用一個kahoot讓我們知道甚麼是能用錢解決的問題都不是問題，php冷知識是真的挺冷的._.<br>聽完錢櫃故事有種駭客都一邊唱歌一邊挖0day的，<del>不揪是最好的社交工程方法</del><br>最後面其實沒講完，我朋友超想聽完的一晚上聽他哀嚎說很想聽完<br>晚上去club之夜，有點遺憾當初高一升高二沒有去AIS3 club，退休了來不及了嗚嗚</p><p>早餐:無<br>午餐:滷味<br>晚餐:主辦請的subway</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>做一整天的專題</p><p>早餐:無<br>午餐:小木屋鬆餅<br>晚餐:中午剩的半個鬆餅</p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><p>早上專題報告<br>下午聽報告:D 我覺得跨域真的就是很跨域ww有區塊鏈工控跟各種東西<br>晚上因為交大二餐沒東西所以跟跨域的朋友跑去清大逛街，清大小熊超可愛要不是錢包不允許超想帶回家<br>全家酷繽沙買一送一，原本要給我朋友結果他在男宿o.O 變成我一個人喝兩杯</p><p>早餐:無<br>午餐:7-11關東煮+熱狗<br>晚餐:清大的蛋包飯</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><p>早上聽軟體報告，真的一組比一組扯的程度，我聽到10個0day那組已經有種，原來0day那麼好挖的嗎的疑惑了<br>下午CTF組報告，聽他們出題有種「沃聽完還是不會解欸」的感覺<br>結束回家結果又下雨= =，來的時候也下離開也下，算是某種有始有終了。</p><p>早餐:無<br>午餐:小木屋鬆餅</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools語法</title>
      <link href="/2025/08/04/pwntools%E8%AA%9E%E6%B3%95/"/>
      <url>/2025/08/04/pwntools%E8%AA%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Pwntools"><a href="#Pwntools" class="headerlink" title="Pwntools"></a>Pwntools</h1><p>記得先 <code>pip3 install pwntools</code></p><span id="more"></span><h2 id="各種語法"><a href="#各種語法" class="headerlink" title="各種語法"></a>各種語法</h2><p><code>gedit 檔名.py</code> 創建檔案<br><code>from pwn import *</code> 引入pwn<br><code>r = remote('主機位址', port)</code> 進行nc連線<br><code>r.recvn(N)</code> 接受 N 個字元<br><code>r.recvline()</code> 接收一行資料<br><code>r.recvlines(N)</code> 接收 N 行資料<br><code>r.recvuntil(some_string)</code> 接收到 some_string 為止🌰<code>r.recvuntil(b'answer: ') </code> (要加b因為recvuntil回傳的是bytes形式)<br><code>r.send(payload)</code> 發送payload(需為字串)<br><code>r.sendline(payload)</code> 發送payload，並換行（末尾\n）<br><code>r.sendafter(some_string, payload)</code> 接收到 some_string 後, 發送 payload<br><code>r.sendlineafter(some_string, payload)</code> 接收到 some_string 後, 發送 payload並換行<br><code>r.interactive()</code> 輸入 logout 離開連接端 shell，與 shell 互動<br><code>r.close()</code> 將remote連線結束</p>]]></content>
      
      
      
        <tags>
            
            <tag> 筆記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark筆記</title>
      <link href="/2025/08/04/wireshark%E7%AD%86%E8%A8%98/"/>
      <url>/2025/08/04/wireshark%E7%AD%86%E8%A8%98/</url>
      
        <content type="html"><![CDATA[<h1 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h1><span id="more"></span><h2 id="一點先備知識🍘🧀"><a href="#一點先備知識🍘🧀" class="headerlink" title="一點先備知識🍘🧀"></a>一點先備知識🍘🧀</h2><ul><li>公用 IP 位址<ul><li>公用 IP 位址向其 Internet 服務提供者 (ISP) 和 Internet 的其餘部分識別電腦。 公用 IP 位址可以唯一地識別一台電腦或充當專用網路的共用存取點</li></ul></li><li>私有 IP 位址<ul><li>識別本地網路內的電腦</li><li>範圍<ul><li>192.168.0.0–192.168.255.255（65,536 個 IP 位址）</li><li>172.16.0.0–172.31.255.255（1,048,576 個 IP 位址）</li><li>10.0.0.0–10.255.255.255（16,777,216 個 IP 位址）</li></ul></li></ul></li><li>Ports<ul><li>Ports 0 to 1023 are Well-Known Ports.<ul><li>通常被指派給特定的網路服務</li><li>21：FTP（File Transfer Protocol）</li><li>22：SSH（Secure Shell）</li><li>80：HTTP（HyperText Transfer Protocol）</li><li>443：HTTPS（HyperText Transfer Protocol Secure）</li></ul></li><li>Ports 1024 to 49151 are Registered Ports.<ul><li>通常用於特定的應用程式或專有軟體</li><li>3306：MySQL 資料庫</li><li>5432：PostgreSQL 資料庫</li><li>27017：MongoDB</li></ul></li><li>Ports 49152 to 65535 are Public Ports.<ul><li>通常用於臨時連線（Ephemeral Ports）</li><li>例如當用戶端連接到伺服器時，系統會自動分配一個動態端口來處理回應</li></ul></li></ul></li></ul><h2 id="常用選項"><a href="#常用選項" class="headerlink" title="常用選項"></a>常用選項</h2><h3 id="統計（Statistics）功能"><a href="#統計（Statistics）功能" class="headerlink" title="統計（Statistics）功能"></a>統計（Statistics）功能</h3><ul><li>協議分級<ul><li>Statistics → Protocol Hierarchy</li><li>會顯示封包中 不同協議的比例</li><li>分析封包裡的 協議組成比例，看看主要的通訊是什麼</li><li>CTF 中可以用來判斷<strong>是否有不尋常的協議？</strong>（例如比賽題目裡偷偷用了某個不常見的協議來藏 flag）</li></ul></li><li>查詢常見IP<ul><li>Statistics -&gt; Conversations -&gt; IPv4 -&gt; Bytes(點擊兩次可使從大到小排序)</li><li>可以列出 <strong>封包最多或流量最高的IP</strong>，幫助找出 <strong>主要通訊的IP</strong> 位址</li><li>在CTF中，通常用來 <strong>找出有價值的 IP</strong> 來進一步分析</li></ul></li></ul><h3 id="檢視下載的資源"><a href="#檢視下載的資源" class="headerlink" title="檢視下載的資源"></a>檢視下載的資源</h3><ul><li>File -&gt; Export Objects -&gt; HTTP (Figure)</li><li>Wireshark 會列出所有 透過 HTTP 下載的檔案（例如 .exe, .png, .zip 等）</li><li>選擇檔案 → 點擊「Save」存下來</li><li>除了 HTTP，也可以試試：<ul><li>Export Objects → SMB（Windows 共享檔案）</li><li>Export Objects → FTP（FTP 傳輸的檔案）</li></ul></li><li>CTF 常見考點：下載被隱藏的檔案，看看裡面藏了什麼（可能是 flag）</li></ul><h2 id="過濾指令"><a href="#過濾指令" class="headerlink" title="過濾指令"></a>過濾指令</h2><h3 id="過濾協議"><a href="#過濾協議" class="headerlink" title="過濾協議"></a>過濾協議</h3><ul><li>直接輸入協議名即可過濾出對應數據。例如：<ul><li>tcp：顯示所有 TCP 數據</li><li>udp：顯示所有 UDP 數據</li><li>arp、icmp、http、smtp、ftp、dns、ssl、ssh 等同理</li></ul></li></ul><h3 id="過濾IP"><a href="#過濾IP" class="headerlink" title="過濾IP"></a>過濾IP</h3><ul><li>常用字段:<ul><li>ip.src：源 IP 地址</li><li>ip.dst：目標 IP 地址</li><li>ip.addr：匹配數據中出現的任一IP 地址（即包括源及目標）</li><li>🌰過濾某個IP的數據:<code>ip.src == 192.168.1.100 or ip.dst == 192.168.1.100</code> or <code>ip.addr == 192.168.1.100</code></li></ul></li><li>不等於<ul><li>Wireshark不支持直接用 <code>!=</code> 表達不等，需要用 <code>not ...==... </code>或 <code>!</code> 來表達</li><li>🌰過濾出TCP端口不為3389 &amp; IP位址不為10.135.71.54 &amp; 端口不為80 : <code>not tcp.port == 3389 and not ip.addr == 10.135.71.54 and not tcp.port == 80 </code></li></ul></li></ul><h3 id="過濾端口"><a href="#過濾端口" class="headerlink" title="過濾端口"></a>過濾端口</h3><ul><li>常用字段:<ul><li>tcp.port：匹配 TCP 數據中（包括源及目標）的端口號</li><li>tcp.srcport 與 tcp.dstport：分别表示 TCP 源端口和目標端口</li><li>udp.port：匹配 UDP 數據的端口號</li></ul></li><li>🌰過濾TCP端口443:<code>tcp.port eq 443</code></li></ul><h3 id="過濾方向"><a href="#過濾方向" class="headerlink" title="過濾方向"></a>過濾方向</h3><ul><li>有時候需要區分流量的方向</li><li>常用關鍵字<ul><li>對IP : <code>src</code>、<code>dst</code>、<code>src and dst</code>、<code>src or dst</code></li><li>對端口 : <code>srcport</code>、<code>dstport</code>、<code>srcport and dstport</code>、<code>srcport or dstport</code></li></ul></li><li>🌰源IP為10.0.0.1 : <code>ip.src == 10.0.0.1</code></li></ul><h3 id="過濾HTTP"><a href="#過濾HTTP" class="headerlink" title="過濾HTTP"></a>過濾HTTP</h3><ul><li>過濾http模式<ul><li><code>http.request.method == "HEAD"</code></li><li><code>http.request.method == "GET"</code></li><li><code>http.request.method == "POST"</code></li></ul></li><li>模糊匹配字符串<ul><li>有時候flag或關鍵信息可能隱藏在URL、Server字段或整個HTTP數據中</li><li>🌰在URL中包含特定字符串:<code>http.request.uri contains "string"</code></li><li>🌰整個HTTP數據中包含某字符串:<code>http contains "string"</code></li></ul></li></ul><h3 id="tcp-stream過濾"><a href="#tcp-stream過濾" class="headerlink" title="tcp stream過濾"></a>tcp stream過濾</h3><ul><li>篩選屬於同一TCP流的數據，便於對話重組和整體分析</li><li>🌰查看TCP流5的數據 : <code>tcp.stream eq 5</code></li></ul><h3 id="過濾字串"><a href="#過濾字串" class="headerlink" title="過濾字串"></a>過濾字串</h3><ul><li>用 <code>contains</code> 來過濾字串 : <ul><li><strong>模糊搜尋</strong>，只要有包含該字串就會被篩選出來</li><li><code>http contains "flag"</code>：搜尋 HTTP 協議的封包內容中有出現 <code>"flag"</code> 字樣的</li><li><code>tcp contains "login"</code>：搜尋 TCP 的 Payload 裡有 <code>"login"</code> 的封包</li><li><code>dns.qry.name contains "example.com"</code>：DNS 查詢中包含特定域名</li></ul></li><li>萬用搜尋 : <ul><li><code>frame contains "string"</code>：搜尋整個封包（不管哪一層）中出現 <code>"string"</code>的封包</li></ul></li></ul><h2 id="CTF常見題型"><a href="#CTF常見題型" class="headerlink" title="CTF常見題型"></a>CTF常見題型</h2><h3 id="PCAP分析"><a href="#PCAP分析" class="headerlink" title="PCAP分析"></a>PCAP分析</h3><ul><li>給一個PCAP檔案，需要利用wireshark篩選出關鍵信息，如隱藏的字符串、密碼、用戶名或flag</li><li>常見技巧<ul><li>使用<strong>filter</strong>排除無關流量</li><li>利用 <strong>follow TCP stream</strong> 重組會話數據</li><li>結合 <strong>Export Objects</strong>功能提取HTTP、FTP等協議中傳輸的文件</li></ul></li></ul><h3 id="HTTP-流量分析"><a href="#HTTP-流量分析" class="headerlink" title="HTTP 流量分析"></a>HTTP 流量分析</h3><ul><li>分析HTTP請求和響應數據，從中提取隱藏信息</li><li>常見技巧:<ul><li>過濾出 GET/POST 請求</li><li>搜尋請求中包含的數據、Cookie、User-Agent等</li><li>檢查響應包中的HTML或JSON數據</li></ul></li></ul><h3 id="USB流量分析"><a href="#USB流量分析" class="headerlink" title="USB流量分析"></a>USB流量分析</h3><ul><li>提供USB流量抓包，考察選手對USB協議中鍵盤輸入或鼠標移動數據的解析能力</li><li>常見技巧<ul><li>根據數據包長度和格式區分鍵盤和鼠標流量</li><li>利用過濾命令，如過濾數據包中某字節範圍(如USB數據中第三個字節代表鑑碼)</li><li>編寫腳本將提取出的鑑碼映射為實際按鍵，從而重構出輸入的內容</li></ul></li></ul><h3 id="工控協議流量分析"><a href="#工控協議流量分析" class="headerlink" title="工控協議流量分析"></a>工控協議流量分析</h3><ul><li>工控協議(如Modbus、IEC 104、MMS)等，需分析協議數據並從中提取FLAG</li><li>常見技巧<ul><li>利用過濾器定位特定功能碼或命令</li><li>根據協議結構找到數據段，進行數據提取和轉碼</li><li>結合wireshark的統計功能(如協議分級、TCP流號) 定位異常或關鍵流量</li></ul></li></ul><h3 id="隱寫或異常流量"><a href="#隱寫或異常流量" class="headerlink" title="隱寫或異常流量"></a>隱寫或異常流量</h3><ul><li>流量中可能隱藏有編碼、加密或經過隱寫處理的數據，需結合其他工具進行解碼和還原</li><li>常見技巧<ul><li>利用過濾器查找包含特殊標誌的字符串或字節序列</li><li>導出 payload數據後嘗試不同的解碼方式</li><li>分析數據包中的異常字段，如錯誤的校驗和、非標準端口 等</li></ul></li></ul><h2 id="題目練習"><a href="#題目練習" class="headerlink" title="題目練習"></a>題目練習</h2><h3 id="CTF-Academy"><a href="#CTF-Academy" class="headerlink" title="CTF Academy"></a><a href="https://ctfacademy.github.io/network/index.htm#NetworkForensics">CTF Academy</a></h3><h3 id="Wireshark-doo-dooo-do-doo…"><a href="#Wireshark-doo-dooo-do-doo…" class="headerlink" title="Wireshark doo dooo do doo…"></a><a href="https://play.picoctf.org/practice/challenge/115?category=4&amp;page=4">Wireshark doo dooo do doo…</a></h3><p>題目給了一個pcapng檔，用wireshark打開他<br>打開會看到一堆TCP其中夾雜一點HTTP<br>在其中一個TCP封包上選擇follow -&gt; TCP stream<br>然後不斷調整stream的數字，最後在第五個找到很像flag的東西<br>看起來就是凱撒密碼，拿去做解密就是flag!</p><h3 id="Wireshark-twoo-twooo-two-twoo…"><a href="#Wireshark-twoo-twooo-two-twoo…" class="headerlink" title="Wireshark twoo twooo two twoo…"></a><a href="https://play.picoctf.org/practice/challenge/110?category=4&amp;page=4">Wireshark twoo twooo two twoo…</a></h3><p>這題一樣是給了一個pcapng檔<br>打開來之後我先照著上一題那樣選follow -&gt; TCP stream<br>翻了一下找到一個picoCTF的字串，繼續往後翻，又翻到一堆picoCTF開頭字串<br>觀察這幾個有甚麼共通點，發現他的Host都是18.217.1.57<br>用過濾器過濾出每個Host:18.217.1.57，用<code>ip.src ==18.217.1.57</code><br>發現一堆HTTP跟DNS中夾雜著一些DNS，觀察一下發現看起來像base64的東西<br>再把dns也過濾出來<code> ip.src ==18.217.1.57 &amp;&amp; dns</code><br>把每個.reddshrimpandherring.com.windomain.local前的字串提取出來拿去做base64解碼，就是flag了 !</p><h3 id="shark-on-wire-1"><a href="#shark-on-wire-1" class="headerlink" title="shark on wire 1"></a><a href="https://play.picoctf.org/practice/challenge/30?category=4&amp;page=5">shark on wire 1</a></h3><p>打開後觀察一下，他跟之前寫的有點不一樣，他比較多的是ARP跟UDP<br>一樣follow TCP stream試試看，發現啥都沒有<br>換選擇follow UDP stream，不斷往後按就找到flag了</p><h3 id="shark-on-wire-2"><a href="#shark-on-wire-2" class="headerlink" title="shark on wire 2"></a><a href="https://play.picoctf.org/practice/challenge/84?category=4&amp;page=4">shark on wire 2</a></h3><h3 id="PcapPoisoning"><a href="#PcapPoisoning" class="headerlink" title="PcapPoisoning"></a><a href="https://play.picoctf.org/practice/challenge/362?category=4&amp;page=2&amp;search=">PcapPoisoning</a></h3><p>這題給了一個封包，裡面充滿各種東西<br>好幾個裡面都寫一樣的東西<br>一個一個找太久了用filter來搜尋<br><code>frame contains "pico"</code><br>找所有封包內容中有出現 “pico” 的位置<br><img src="https://hackmd.io/_uploads/BkHq67SJex.png" alt="image"><br>找到flag了!</p><h3 id="Packets-Primer"><a href="#Packets-Primer" class="headerlink" title="Packets Primer"></a><a href="https://play.picoctf.org/practice/challenge/286?category=4&amp;page=1&amp;search=Packets%20Primer">Packets Primer</a></h3><p>這題給了一個pcap檔案<br>打開來只有少少幾個封包<br>翻了一下就在其中一個封包裡面看到flag了<br><img src="https://hackmd.io/_uploads/SkZXLNBygg.png" alt="image"></p><h3 id="Eavesdrop"><a href="#Eavesdrop" class="headerlink" title="Eavesdrop"></a><a href="https://play.picoctf.org/practice/challenge/264?category=4&amp;page=1&amp;search=Eavesdrop">Eavesdrop</a></h3><p>這題給了一個pcap，打開之後是一些tcp封包<br>先用follow tcp stream<br>在 stream 0 可以看到一段對話，告訴我們解密方法跟去哪找密文<del>但其實我發現繼續翻tcp stream就可以看到了根本不用搜port</del><br>找到之後要<strong>先將他翻成hex格式</strong>，不能用ascii格式<br>然後要存成binary格式<br><code>echo "53616c7465645f5f3c4b26e8b8f91e2c4af8031cfaf5f8f16fd40c25d40314e6497b39375808aba186f48da42eefa895" | xxd -r -p &gt; file.des3</code><br>然後用題目給的解密方法<br><code>openssl des3 -d -salt -in file.des3 -out file.txt -k supersecretpassword123</code><br>打開解密出來的檔案就是flag了<br><img src="https://hackmd.io/_uploads/H1WaoVBkxx.png" alt="image"></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.checkpoint.com/tw/cyber-hub/network-security/what-is-an-ip-address/">What is an IP Address</a><br><a href="https://cloud.tencent.com/developer/article/1618433">wireshark常用过滤命令</a><br><a href="https://medium.com/@yansi.keim/wireshark-basics-http-traffic-analysis-for-playing-ctf-competitions-f165778e99e2">Wireshark Basics (HTTP Traffic Analysis) for playing CTF Competitions</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 筆記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Disk筆記</title>
      <link href="/2025/08/04/Disk%E7%AD%86%E8%A8%98/"/>
      <url>/2025/08/04/Disk%E7%AD%86%E8%A8%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h1><h2 id="Sleuth-Kit（TSK）指令整理"><a href="#Sleuth-Kit（TSK）指令整理" class="headerlink" title="Sleuth Kit（TSK）指令整理"></a>Sleuth Kit（TSK）指令整理</h2><span id="more"></span><h3 id="img-stat"><a href="#img-stat" class="headerlink" title="img_stat"></a>img_stat</h3><ul><li>用途：查看磁碟映像檔的基本資訊（大小、磁區大小、類型、分割資訊）</li><li>使用時機：拿到 .img 或 .dd 檔的第一步，先了解這顆磁碟的結構</li><li>🌰 <code>img_stat disk.img</code></li></ul><h3 id="mmls"><a href="#mmls" class="headerlink" title="mmls"></a>mmls</h3><ul><li>用途：顯示磁碟映像檔內的分割區資訊（MBR/GPT 分割區表）</li><li>使用時機：確認檔案系統從哪個 offset 開始，供後續指令使用</li><li>🌰<code>mmls disk.img</code></li><li>📌 注意 Start 欄位的數值，後續像 fls、icat 要用 <code>-o &lt;offset&gt;</code></li></ul><h3 id="fsstat"><a href="#fsstat" class="headerlink" title="fsstat"></a>fsstat</h3><ul><li>用途：顯示某個檔案系統的細節（例如 FAT/EXT/NTFS 的 metadata 結構）</li><li>使用時機：分析文件系統類型與結構</li><li>🌰<code>fsstat -o 2048 disk.img</code></li></ul><h3 id="fls"><a href="#fls" class="headerlink" title="fls"></a>fls</h3><ul><li>用途：列出檔案系統中的檔案與目錄（包含已刪除的）</li><li>使用時機：找到目標檔案或目錄（例如 flag.txt 或特定資料夾）</li><li>🌰<code>fls -o 2048 -r disk.img</code></li><li>🌰<code>fls -o 2048 -r disk.img 16</code></li></ul><h3 id="ffind"><a href="#ffind" class="headerlink" title="ffind"></a>ffind</h3><ul><li>用途：透過檔案名稱找出 inode 號碼</li><li>使用時機：若你知道檔名（例如 “flag.txt”）但不想手動看 fls 結果，可快速找 inode</li><li>🌰 <code>ffind -o 2048 disk.img flag.txt</code></li></ul><h3 id="tsk-recover"><a href="#tsk-recover" class="headerlink" title="tsk_recover"></a>tsk_recover</h3><ul><li>用途：從映像檔中恢復檔案（包含刪除檔）</li><li>使用時機：想直接將檔案系統內容 dump 出來分析（不用一個個 icat）</li><li>🌰<code>tsk_recover -o 2048 disk.img output_dir/</code></li><li><blockquote><p>會把整個分割區的檔案複製到 output_dir，可以直接用 ls 看</p></blockquote></li></ul><h3 id="icat"><a href="#icat" class="headerlink" title="icat"></a>icat</h3><ul><li>用途：依 inode 號碼從映像檔中提取單一檔案</li><li>使用時機：用 fls 找到特定檔案 inode 後，用來匯出內容</li><li>作用檔案：磁碟映像檔</li><li>🌰<code>icat -o 2048 disk.img 128</code></li><li>📌 上面會把 inode 為 128 的檔案內容印出來，可以用 &gt; output 存檔</li></ul><h3 id="istat"><a href="#istat" class="headerlink" title="istat"></a>istat</h3><ul><li>用途：顯示指定 inode 的 metadata（建立時間、大小、狀態）</li><li>使用時機：想知道檔案什麼時候被建立、是否刪除、還在不在</li><li>🌰 <code>istat -o 2048 disk.img 128</code></li><li>📌 刪除檔案也會有 metadata（可能幫助你確認「flag.txt 是不是被刪掉」）</li></ul><h3 id="blkls"><a href="#blkls" class="headerlink" title="blkls"></a>blkls</h3><ul><li>用途：直接印出資料區塊（raw data）</li><li>使用時機：想用 strings 擷取出某些資料，像是被藏起來的 flag、png 頭之類的 raw data</li><li>🌰 <code>blkls -o 2048 disk.img &gt; raw.bin &amp;&amp; strings raw.bin | grep CTF</code></li></ul><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><h3 id="picoCTF-Sleuthkit-Intro"><a href="#picoCTF-Sleuthkit-Intro" class="headerlink" title="picoCTF-Sleuthkit Intro"></a><a href="https://play.picoctf.org/practice/challenge/301?category=4&amp;page=3&amp;search=">picoCTF-Sleuthkit Intro</a></h3><p>題目給了一個img檔案跟一個nc連線的資訊<br>先連線上去看他要問什麼，他要問的是Linux部分的長度<br><img src="https://hackmd.io/_uploads/SylCp1_0Jx.png" alt="image"><br>題目已經有告訴我們要用mmls了，所以就<code>mmls disk.img</code><br><img src="https://hackmd.io/_uploads/rkx1CydA1e.png" alt="image"><br>第三行的length就是答案了，送出答案就會得到flag了</p><h3 id="picoCTF-Sleuthkit-Apprentice"><a href="#picoCTF-Sleuthkit-Apprentice" class="headerlink" title="picoCTF-Sleuthkit Apprentice"></a><a href="https://play.picoctf.org/practice/challenge/300?category=4&amp;page=3&amp;search=">picoCTF-Sleuthkit Apprentice</a></h3><p>題目給了一個disk檔<br>下載之後用<code>gunzip</code>解壓縮<br>然後用<code>mmls</code>查看分隔區表<br><img src="https://hackmd.io/_uploads/SyQvP5D01l.png" alt="image"><br>有兩個Linux分隔區<br>分別用<code>fsstat -o 2048 disk.flag.img </code>跟<code>fsstat -o 360448 disk.flag.img</code>查看內容<br>發現第二個<code>Last mounted on: /</code>所以應該是要找這個<br><img src="https://hackmd.io/_uploads/HkcRDcwA1x.png" alt="image"><br>用<code>fls -o 360448 disk.flag.img</code>查看目錄<br>然後<code>fls -o 360448 disk.flag.img 1995</code>發現root下有資料夾<br><code>fls -o 360448 disk.flag.img 3981</code>找到兩個檔案(一個被刪除了)<br>用<code>tsk_recover -e -o 360448 disk.flag.img -d 3981 Apprentice/</code>導出資料夾裡的所有檔案，cat 檔案就能找到flag</p><h3 id="picoCTF-Disk-disk-sleuth"><a href="#picoCTF-Disk-disk-sleuth" class="headerlink" title="picoCTF-Disk, disk, sleuth!"></a><a href="https://play.picoctf.org/practice/challenge/113?category=4&amp;page=4&amp;search=">picoCTF-Disk, disk, sleuth!</a></h3><p>這題說要用srch_strings，上網查發現它可以印出可視字串<br>直接使用會噴出一堆東西，所以要搭配grep進行搜尋<br><code>srch_strings dds1-alpine.flag.img | grep "CTF"</code>然後就找到flag了</p><h3 id="picoCTF-Disk-disk-sleuth-II"><a href="#picoCTF-Disk-disk-sleuth-II" class="headerlink" title="picoCTF-Disk, disk, sleuth! II"></a><a href="https://play.picoctf.org/practice/challenge/137?category=4&amp;page=4&amp;search=">picoCTF-Disk, disk, sleuth! II</a></h3><p>這題一樣解壓縮後用 <code>mmls dds2-alpine.flag.img</code>確認分隔區<br>我們現在知道要找的檔案的名字，所以可以直接讓他列出全部的檔案再搜尋<br><code>fls -o 2048 -r dds2-alpine.flag.img| grep "down-at-the-bottom"</code><br><img src="https://hackmd.io/_uploads/SyWy65DC1g.png" alt="image"><br>找到之後用<code>icat -o 2048 dds2-alpine.flag.img 18291 &gt; dds2.txt</code>提取檔案<br><code>cat dds2.txt</code>會出現<img src="https://hackmd.io/_uploads/H1XLQp9vCye.png" alt="image"><br>組合起來就是flag</p><h3 id="picoCTF-Operation-Oni"><a href="#picoCTF-Operation-Oni" class="headerlink" title="picoCTF-Operation Oni"></a><a href="https://play.picoctf.org/practice/challenge/284?category=4&amp;page=3&amp;search=">picoCTF-Operation Oni</a></h3><p>下載之後解壓縮，用mmls查看分隔區<br>分別用<code>fsstat -o 2048 disk.img </code>跟<code>fsstat -o 206848 disk.img</code>查看內容<br>發現第二個<code>Last mounted on: /</code>所以應該是要找這個<br><code>fls -o 206848 disk.img</code>然後通常私鑰預設就會存在<code>root</code>底下<br>進去root看看<code>fls -o 206848 disk.img 470</code><br><img src="https://hackmd.io/_uploads/BJBC91OCJl.png" alt="image"><br>看到一個叫.ssh的目錄，再進去可以看到兩個檔案<br><img src="https://hackmd.io/_uploads/SkG7j1uCJg.png" alt="image"><br>分別查看兩個檔案內容<br><img src="https://hackmd.io/_uploads/rJHCql5bxx.png" alt="螢幕擷取畫面 2025-05-20 204954"><br>導出id_ed25519這個檔案<code>icat -o 206848 disk.img 2345 &gt; ssh1.txt</code><br>然後加權限給他<code>chmod 600 ssh1.txt</code><br>用這個檔案進行ssh連線後<code>cat flag.txt</code>就找到flag了<br><img src="https://hackmd.io/_uploads/Bkc9jyuRJg.png" alt="image"></p><h3 id="picoCTF-Operation-Orchid"><a href="#picoCTF-Operation-Orchid" class="headerlink" title="picoCTF-Operation Orchid"></a><a href="https://play.picoctf.org/practice/challenge/285?category=4&amp;page=3&amp;search=">picoCTF-Operation Orchid</a></h3><p>解壓縮後用<code>mmls</code>查看分隔區表<br><img src="https://hackmd.io/_uploads/B1BWM-cZlx.png" alt="image"><br>一跟三是linux分隔區，分別用<code>fsstat</code>查看內容<br><img src="https://hackmd.io/_uploads/Bkhk3b9-ge.png" alt="image"><img src="https://hackmd.io/_uploads/S1O-n-cbex.png" alt="image"><br>第三個<code>Last mounted on: /</code>所以猜是在第三個這個裡面<br>用<code>fls -o 411648 disk.flag.img</code>查看一下目錄<img src="https://hackmd.io/_uploads/S1HOnW5bex.png" alt="image"><br>查看root目錄，發現加密過的flag檔案<br><img src="https://hackmd.io/_uploads/ryxA2Wcblg.png" alt="image"><br>用 <code>strings -t d disk.flag.img | grep flag.txt</code>尋找金鑰在哪<br><img src="https://hackmd.io/_uploads/H1xVaW9bel.png" alt="image"><br>找到<code>openssl aes256 -salt -in flag.txt -out flag.txt.enc -k unbreakablepassword1234567</code><br>用<code>icat -o 411648 disk.flag.img 1782 &gt; flag.txt.enc</code>導出檔案，再用密鑰進行解密，然後就可以得到flag<br><img src="https://hackmd.io/_uploads/rkei6ZcWxe.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 筆記 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
